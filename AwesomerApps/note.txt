- General Notes
    - primeNG lib
    - 
- Building Awesomer Apps with Angular, Part 2
    - ES6 module
        - allow you to organize application into kinds of blocks that see each others
        - it's an organizational mechanisms at the language level and that's allow to organize our code and put it back together
    - Route
        - it's a way to define a specific state/pages in application
        - path: '**'  it's a wild card that will be available for any pages that does NOT exist
    - Component
        - they are lagos of any application
        - fundamental building block for the application
        - encapsulated a bit of functionality that we can use it whatever we want
        - ngOnInit : it's part of life cycle hooks that start after the constructor done, but it fires when the initial state is ready
        - we inject the service in the constructor with PRIVATE keyword because to take the parameter and assign it to local variable with the same name .
        - a two property that a component decelerator must have is [ selector, template ]
        - Binding
            - sending data from class to template - string interpolation => {{value}}
            - sending data from class to template - property binding     => [property]='value'
            - sending data from template to class - event binding        => (event)="handler"
            - sending data two way data binding                          => [(ngModel)]='property'
        - Component have template but Directive modify an existing template
    - Services
        - Business logic
        - it literary just a class
- Forms
    - In every form there are two kinds of things that need to track
        - state of the form     => mean valid/not valid
        - data of the form  
    - Template Driven Forms
        - To use it we must import FormsModule
        - FormsModule
            - enable two-way data binding withing a form
            - creates a form control instance from a domain model and binds it to from element
            - we can create a local variable to reference the ngModel instance of the element
        - FormControls
            - ngControl     : binds a DOM element to FormControl
            - Form Control  : responsible for tracking value and validation status of a single form element
            - you can group FormControls together with FormGroup
            - ngForm        : binds an HTML form to top-level FormGroup
            - we can create a local variable to reference the ngForm instance of the form
            - ngModelGroup  : creates and binds a FormGroup instance to DOM element
        - Validation Styles
            - Angular will automatically attach styles to a form element depending on it's state
            - for instance, if it in a valid state      then the ng-valid   is attached
            - if the element is in an invalid state     then the ng-invalid is attached
            - there are additional styles such as ng-pristine and ng-untouched
                - pristine is have you ever touched it at all.
- Component Composition
    - Component Driven Architecture 
        - Component are small, encapsulated pieces of software that can be reused in many different contexts
        - Angular strongly encourages the component Architecture by making it easy to build out every feature of an app as component 
        - Angular Component self encapsulated building block that contain thier own tempaltes, styles and logic so they can be easly ported else where 
    - Clear contract with @Input and @Output
        - Represents an agreement between the software developer and software user - or the supplier and the consumer 
        - Inputs and Outputs define the interface of a component.
        - These then act as a contract to any component that wants to consume it.
        - Also act as a visual aid so that we can infer what a component does just by looking at it's input and outputs.
    - @Input 
        - Allows data to flow from a parent component to child component.
        - Defined inside a component via the @Input decelerator: @Input someValue: string;
        - Bind In parent template: <component [someValue]="value"></component>
        - We can alias inputs @Input('alias') someValue: string;
    - @Output
        - Expose an EventEmitter property that emits events to the parent component.
        - Defined inside a component via the @Output decorator: @Output() someValue = new EventEmitter();
        - Bind in parent tempalte: <cmp (someValue)="handleValue()"></cmp>
    - Container and Presentational Component 
        - Container component are connected to Services.
        - Container component know how to load thier own data, and how to persist changes.
        - Presentational component are fully defined by thier bindings so thier is no logic in this component. 
        - All data goes in as input, and every change come out as an output.
        - Create as few container component/many presentational component as possible.

    `SHARED STATE IS NOT A BAD THING, MUTABLE STATE IS NOT A BAD THING, SHARE MUTABLE STATE IS A DEVIEL 
    WHEN YOU HAVE STATE THAT SHARED WITH MUTABLE COMPONENTS AND ANY COMPONENT CAN MUTATE THAT SATE 
    NOW U CAN PUT EVERY OTHER COMPONENT THAT DEPEND ON THIS STATE IN THE RISK`

- Server Communication
    - HTTP Module 
        - Simplifies usage of the XHR and JSONP APIs
        - API conveniently matches RESTful verbs
        - Returns an Observalbes
    - HTTP Module Method
        - request
            - performs any types of http request  
        - get 
            - performs a request with GET http method
        - post 
            - performs a request with POST http method
        - put 
            - performs a request with PUT http method
        - delete 
            - performs a request with DELETE http method
        - patch 
            - performs a request with PATCH http method
        - head 
            - performs a request with HEADE http method
    - Observalbes.toPromise 
        - Diving into observalbes can be intimidating.
        - We can chain any HTTP method (or any observalbe for the matter) with toPromise.
        - Then we can use .then and .catch to resolve the promise as always.
        - Promises can do one thing, but Observalbes can do a lot of things.
    - Observalbes.subscribe 
        - We finalize an observalbe stream by subscribing to it.
        - The subscribe method accepts three events handlers 
            - onNext        is called when new data arrives. 
            - onError       is called when an error is thrown. 
            - onComplete    is called when the stream is completed.
    - Headers 
        - Http module methods have an optional second paramter which is RequestOptions object.
        - The RequestOptions object has a headers property which is a Headers object.
        - We can use the Headers Object to set additional parameters like Content-Type.
    - Error Handling 
        - Use Observalbe.catch to process the error at the service level.
        - Use Observalbe.throw to force an error further down the stream. 
        - Use the error handler in the subscribe method to respond to the error at the component level.

- Observalbes Fundamentals 
    - Observer and Iterator Patten 
        - Iterator: An abstract mechanism for accessing the elements in a collection.
        - Observer: The Observer pattern has two participants, Observers and Observables 
                    and defines a one to many relationship between them. An Observerable object contains a list of its Observers.
        - Observable is a two classic communication btw two design pattern
        - Iterator pattern design to communicate state
        - We use observer pattern & Iterator pattern to communicate state over time.
        - Observer Pattern 
            - Think of Observable as a function that “throws” values.
              It can “throw” values in synchrony or asynchrony way. 
              If you have interest on this values, you can register observer.
            - The Observer is an object, with three functions.
                - next() => Observable, please call this function when you have a new value for me.
                - error() => Observable, please call this function when you have a new error for me.
                - complete() => Observable, please call this function when you complete your job.
            - With Observable it’s like, don’t call us we call you.
            - The Observable is the boss. When he has a new value, he will push the value to you. Your job is just to “listen.”

    - Basic Observable Sequence
        - Observable.map 
        - Observable.filter
    - Basic Sequence
        - initial output -> magic       -> final input
        - event          -> operators   -> subscribe
    - Observable Demonstration










- Observalbes 
    - stream => it's a series of values in time.
    -